/* jshint esnext:true */
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _videoJs = require('video.js');

var _videoJs2 = _interopRequireDefault(_videoJs);

var debounce = require('throttle-debounce').debounce;

// Default options for the plugin.
var defaults = {
  debounceDelay: 200,
  layoutMap: [{ layoutClassName: 'vjs-layout-tiny', width: 2 }, { layoutClassName: 'vjs-layout-x-small', width: 3 }, { layoutClassName: 'vjs-layout-small', width: 4 }, { layoutClassName: 'defaults', width: 5 }]
};

/**
 * Retrieve the outerWidth of an element, including margins
 *
 * @function getElementOuterWidth
 * @param    {Element} el to measure
 * @return   {number} the width of the element in pixels
 */
var _getElementOuterWidth = function _getElementOuterWidth(el) {
  var width = el.offsetWidth;
  var style = getComputedStyle(el);

  width += parseInt(style.marginLeft, 10) + parseInt(style.marginRight, 10);
  return width;
};

/**
 * Retrieve the width an element
 *
 * @function getElementWidth
 * @param    {Element} el to measure
 * @return   {number} the width of the element in pixels
 */
var _getElementWidth = function _getElementWidth(el) {
  return parseInt(getComputedStyle(el).width, 10);
};

/**
 * Check if an element is currently visible.
 *
 * Use this to filter on elements that should be taken into account during calculations.
 *
 * @function isElementVisible
 * @param    {Element} el to test
 * @return   {boolean} true if el is visible
 */
var _isElementVisible = function _isElementVisible(el) {
  return el.offsetWidth > 0 || el.offsetHeight > 0;
};

var dimensionsCheck = function dimensionsCheck() {
  /**
   * Set a layout class on a video-js element
   *
   * @function setLayout
   * @param    {Player} player to apply the layout to
   */
  var setLayout = function setLayout(layouter) {
    var el = layouter.player.el();
    var layoutDefinition = layouter.options.layoutMap[layouter.currentLayout_];

    if (layoutDefinition.layoutClassName !== 'defaults') {
      _videoJs2['default'].addClass(el, layoutDefinition.layoutClassName);
    }
    layouter.options.layoutMap.forEach(function (element, index) {
      if (index !== layouter.currentLayout_ && element.layoutClassName !== 'defaults') {
        _videoJs2['default'].removeClass(el, element.layoutClassName);
      }
    });
  };

  /**
   * Calculate for the giving dimensions which layout class of the layoutMap should be
   * used
   *
   * @function setLayout
   * @param    {Player} player to apply the layout to
   */
  var calculateLayout = function calculateLayout(layouter, playerWidth, controlBarWidth, controlWidth) {
    var layoutMap = layouter.options.layoutMap;

    if (controlBarWidth > playerWidth && layouter.currentLayout_ > 0) {
      // smaller
      layouter.currentLayout_--;
      setLayout(layouter);
      window.setTimeout(dimensionsCheck.bind(layouter), 1);
    } else if (layouter.currentLayout_ < layoutMap.length - 1 && playerWidth >= layoutMap[layouter.currentLayout_ + 1].width * controlWidth) {
      // bigger
      layouter.currentLayout_++;
      setLayout(layouter);
      window.setTimeout(dimensionsCheck.bind(layouter), 1);
    }
  };

  if (!this.el || this.player.usingNativeControls() || !_isElementVisible(this.el.querySelectorAll('.vjs-control-bar')[0])) {
    return;
  }
  var playerWidth = this.getPlayerWidth();
  var controlWidth = this.getControlWidth();
  var controlBarWidth = this.getControlBarWidth();

  if (this.options.calculateLayout) {
    this.options.calculateLayout(this, playerWidth, controlBarWidth, controlWidth);
  } else {
    calculateLayout(this, playerWidth, controlBarWidth, controlWidth);
  }
};

var Layouter = (function () {
  function Layouter(player, options) {
    _classCallCheck(this, Layouter);

    this.player_ = player;
    this.options_ = options;
    this.currentLayout_ = options.layoutMap.length - 1;
    this.debouncedCheckSize_ = debounce(options.debounceDelay, dimensionsCheck);
  }

  /**
   * A video.js plugin.
   *
   * In the plugin function, the value of `this` is a video.js `Player`
   * instance. You cannot rely on the player being in a "ready" state here,
   * depending on how the plugin is invoked. This may or may not be important
   * to you; if not, remove the wait for "ready"!
   *
   * @function responsiveLayout
   * @param    {Object} [options={}]
   *           An object of options left to the plugin author to define.
   */

  _createClass(Layouter, [{
    key: 'ready',
    value: function ready() {
      var _this = this;

      this.player.addClass('vjs-responsive-layout');

      this.windowResizeListener_ = window.addEventListener('resize', function () {
        return _this.debouncedCheckSize_();
      });

      this.player.on(['play', 'resize'], function () {
        return _this.debouncedCheckSize_();
      });
      this.player.on('dispose', function () {
        window.removeEventListener('resize', this.windowResizeListener_);
      });

      // Let's do the first measure
      this.player.trigger('resize');
    }

    /**
     * Retrieve player to which this Layouter object belongs
     *
     * @property player
     * @return   {number} the width of the controlbar in pixels
     */
  }, {
    key: 'getControlWidth',

    /**
     * Retrieve current width of a control in the video.js controlbar
     *
     * This function relies on the presence of the play control. If you
     * mess with it's visibility, things likely will break :)
     *
     * @function getControlWidth
     * @return   {number} the width of the controlbar in pixels
     */
    value: function getControlWidth() {
      return _getElementOuterWidth(this.el.querySelectorAll('.vjs-play-control')[0]);
    }

    /**
     * Retrieve current width of the video.js controlbar
     *
     * @function getControlBarWidth
     * @return   {number} the width of the controlbar in pixels
     */
  }, {
    key: 'getControlBarWidth',
    value: function getControlBarWidth() {
      var controlBarWidth = 0;
      var cbElements = this.el.querySelectorAll('.vjs-control-bar > *');

      Array.from(cbElements).forEach(function (el) {
        if (_isElementVisible(el)) {
          controlBarWidth += _getElementOuterWidth(el);
        }
      });
      return controlBarWidth;
    }

    /**
     * Retrieve current width of the video.js player element
     *
     * @function getPlayerWidth
     * @return   {number} the width of the player in pixels
     */
  }, {
    key: 'getPlayerWidth',
    value: function getPlayerWidth() {
      return _getElementWidth(this.el);
    }

    /**
     * Retrieve the outerWidth of an element, including margins
     *
     * @function outerWidth
     * @param    {Element} el to measure
     * @return   {number} the width of the element in pixels
     */
  }, {
    key: 'player',
    get: function get() {
      return this.player_;
    }
  }, {
    key: 'el',
    get: function get() {
      return this.player_.el();
    }
  }, {
    key: 'options',
    get: function get() {
      return this.options_;
    }
  }], [{
    key: 'getElementOuterWidth',
    value: function getElementOuterWidth(el) {
      return _getElementOuterWidth(el);
    }

    /**
     * Retrieve the width an element
     *
     * @function getElementWidth
     * @param    {Element} el to measure
     * @return   {number} the width of the element in pixels
     */
  }, {
    key: 'getElementWidth',
    value: function getElementWidth(el) {
      return _getElementWidth(el);
    }

    /**
     * Check if an element is currently visible.
     *
     * Use this to filter on elements that should be taken into account during calculations.
     *
     * @function isElementVisible
     * @param    {Element} el to test
     * @return   {boolean} true if el is visible
     */
  }, {
    key: 'isElementVisible',
    value: function isElementVisible(el) {
      return _isElementVisible(el);
    }
  }]);

  return Layouter;
})();

var responsiveLayout = function responsiveLayout(options) {
  var layout = new Layouter(this, _videoJs2['default'].mergeOptions(defaults, options));

  this.ready(function () {
    layout.ready();
  });
};

// Register the plugin with video.js.
_videoJs2['default'].plugin('responsiveLayout', responsiveLayout);

exports['default'] = responsiveLayout;
module.exports = exports['default'];